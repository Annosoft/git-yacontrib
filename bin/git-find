#! /bin/sh

SUBDIRECTORY_OK=1
OPTIONS_SPEC="\
git find [ -w | -r ] -- <find(1)-opts>

Invoke find(1) just on the (-w)orking copy or (-r)epository.
The default is to operate on the current directory, as \$PWD.

Find in the working copy will also reach the working trees of any
submodules, but not their .git/ directory.

When .git/ is skipped, this is done with the -prune option, which has
no effect if -depth or -delete are given and can cause the directory
to be printed if no other action is given.
--
r   Operate only on the repository (.git/)
w   Operate on files from the top of the working copy (exclude .git/)
n   Do nothing, only print the find command."

. "$(git --exec-path)/git-sh-setup"


# Read opts - normalised by "git rev-parse --parseopt"
unset in_where no_op
while [ $# -gt 0 ]; do
    sw="$1"
    shift
    case "$sw" in
        -r) in_where=r ;;
        -w) in_where=w ;;
        -n) no_op=echo ;;
        --) break ;;
        *) die "Bad option '$sw'" ;;
    esac
done

# Do
case $in_where in
    r) exec $no_op find "$GIT_DIR/" "$@" ;;
    w) exec $no_op find "$( git rev-parse --show-toplevel )/" \
        -type d -name .git -prune -true -o "$@" ;;
    *) exec $no_op find "$PWD/" \
        -type d -name .git -prune -true -o "$@" ;;
esac
# Trailing / on every dirname to "follow symlink" there.
